"""
@generated by mypy-protobuf.  Do not edit manually!
isort:skip_file

License
"""

import builtins
import collections.abc
import google.protobuf.descriptor
import google.protobuf.internal.containers
import google.protobuf.internal.enum_type_wrapper
import google.protobuf.message
import sys
import typing

if sys.version_info >= (3, 10):
    import typing as typing_extensions
else:
    import typing_extensions

DESCRIPTOR: google.protobuf.descriptor.FileDescriptor

class _BriarServiceStatus:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _BriarServiceStatusEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_BriarServiceStatus.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    UNKNOWN: _BriarServiceStatus.ValueType  # 0
    READY: _BriarServiceStatus.ValueType  # 1
    ERROR: _BriarServiceStatus.ValueType  # 2
    BUSY: _BriarServiceStatus.ValueType  # 3

class BriarServiceStatus(_BriarServiceStatus, metaclass=_BriarServiceStatusEnumTypeWrapper):
    """----------------------------------------------------------------------------
    Initialization

    Representation of the service's current status
    """

UNKNOWN: BriarServiceStatus.ValueType  # 0
READY: BriarServiceStatus.ValueType  # 1
ERROR: BriarServiceStatus.ValueType  # 2
BUSY: BriarServiceStatus.ValueType  # 3
global___BriarServiceStatus = BriarServiceStatus

class _ExtractFlags:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _ExtractFlagsEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_ExtractFlags.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    EXTRACT_FULL_IMAGE: _ExtractFlags.ValueType  # 0
    EXTRACT_AUTO_DETECTION: _ExtractFlags.ValueType  # 1
    EXTRACT_PROVIDED_DETECTION: _ExtractFlags.ValueType  # 2

class ExtractFlags(_ExtractFlags, metaclass=_ExtractFlagsEnumTypeWrapper):
    """Flag tells service what mode to run in when running an extract command"""

EXTRACT_FULL_IMAGE: ExtractFlags.ValueType  # 0
EXTRACT_AUTO_DETECTION: ExtractFlags.ValueType  # 1
EXTRACT_PROVIDED_DETECTION: ExtractFlags.ValueType  # 2
global___ExtractFlags = ExtractFlags

class _EnrollFlags:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _EnrollFlagsEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_EnrollFlags.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    ENROLL_FULL_IMAGE: _EnrollFlags.ValueType  # 0
    """Do not run detections: extract from whole image"""
    ENROLL_AUTO_DETECTION: _EnrollFlags.ValueType  # 1
    """Run detection on the image, generate detections"""
    ENROLL_PROVIDED_DETECTION: _EnrollFlags.ValueType  # 2
    """Extract and enroll from provided detections"""
    ENROLL_PROVIDED_TEMPLATE: _EnrollFlags.ValueType  # 3
    """Enroll from provided template"""

class EnrollFlags(_EnrollFlags, metaclass=_EnrollFlagsEnumTypeWrapper):
    """Flags tell service what mode to run in when running enroll command"""

ENROLL_FULL_IMAGE: EnrollFlags.ValueType  # 0
"""Do not run detections: extract from whole image"""
ENROLL_AUTO_DETECTION: EnrollFlags.ValueType  # 1
"""Run detection on the image, generate detections"""
ENROLL_PROVIDED_DETECTION: EnrollFlags.ValueType  # 2
"""Extract and enroll from provided detections"""
ENROLL_PROVIDED_TEMPLATE: EnrollFlags.ValueType  # 3
"""Enroll from provided template"""
global___EnrollFlags = EnrollFlags

class _VerifyFlags:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _VerifyFlagsEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_VerifyFlags.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    VERIFY_FULL_IMAGE: _VerifyFlags.ValueType  # 0
    """Create template from the entire image and use resulting template"""
    VERIFY_AUTO_DETECTION: _VerifyFlags.ValueType  # 1
    VERIFY_PROVIDED_DETECTIONS: _VerifyFlags.ValueType  # 2
    """Create templates from the provided detections"""
    VERIFY_PROVIDED_TEMPLATES: _VerifyFlags.ValueType  # 3
    """Use provided templates"""

class VerifyFlags(_VerifyFlags, metaclass=_VerifyFlagsEnumTypeWrapper):
    """Flag tells service what mode to run in when running verify command"""

VERIFY_FULL_IMAGE: VerifyFlags.ValueType  # 0
"""Create template from the entire image and use resulting template"""
VERIFY_AUTO_DETECTION: VerifyFlags.ValueType  # 1
VERIFY_PROVIDED_DETECTIONS: VerifyFlags.ValueType  # 2
"""Create templates from the provided detections"""
VERIFY_PROVIDED_TEMPLATES: VerifyFlags.ValueType  # 3
"""Use provided templates"""
global___VerifyFlags = VerifyFlags

class _SearchFlags:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _SearchFlagsEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_SearchFlags.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    SEARCH_FULL_IMAGE: _SearchFlags.ValueType  # 0
    """Create template from the entire image and use resulting template"""
    SEARCH_AUTO_DETECTION: _SearchFlags.ValueType  # 1
    """Run detection on image, generate detections, extract templates, and search"""
    SEARCH_PROVIDED_DETECTIONS: _SearchFlags.ValueType  # 2
    """Create templates from the provided detections"""
    SEARCH_PROVIDED_TEMPLATES: _SearchFlags.ValueType  # 3
    """Use provided templates"""

class SearchFlags(_SearchFlags, metaclass=_SearchFlagsEnumTypeWrapper):
    """Tells service what mode to run in when running search command"""

SEARCH_FULL_IMAGE: SearchFlags.ValueType  # 0
"""Create template from the entire image and use resulting template"""
SEARCH_AUTO_DETECTION: SearchFlags.ValueType  # 1
"""Run detection on image, generate detections, extract templates, and search"""
SEARCH_PROVIDED_DETECTIONS: SearchFlags.ValueType  # 2
"""Create templates from the provided detections"""
SEARCH_PROVIDED_TEMPLATES: SearchFlags.ValueType  # 3
"""Use provided templates"""
global___SearchFlags = SearchFlags

class _EntryType:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _EntryTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_EntryType.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    ENTRY_TYPE_UNKNOWN: _EntryType.ValueType  # 0
    """Not typically used"""
    ENTRY_TYPE_SUBJECT: _EntryType.ValueType  # 1
    """Entry corresponds to a person (gallery) and entries should be aggregated under a person_id"""
    ENTRY_TYPE_MEDIA: _EntryType.ValueType  # 2
    """Entry corresponds to media (probe) and entries should be under a media_id"""

class EntryType(_EntryType, metaclass=_EntryTypeEnumTypeWrapper): ...

ENTRY_TYPE_UNKNOWN: EntryType.ValueType  # 0
"""Not typically used"""
ENTRY_TYPE_SUBJECT: EntryType.ValueType  # 1
"""Entry corresponds to a person (gallery) and entries should be aggregated under a person_id"""
ENTRY_TYPE_MEDIA: EntryType.ValueType  # 2
"""Entry corresponds to media (probe) and entries should be under a media_id"""
global___EntryType = EntryType

class _BiometricModality:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _BiometricModalityEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_BiometricModality.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    UNSPECIFIED: _BiometricModality.ValueType  # 0
    """Use the fusion of all available modalities."""
    WHOLE_BODY: _BiometricModality.ValueType  # 1
    """deprecated.  Use BODY for general body appearance or features"""
    FACE: _BiometricModality.ValueType  # 2
    GAIT: _BiometricModality.ValueType  # 3
    BODY: _BiometricModality.ValueType  # 4
    ANTHROPOMETRY: _BiometricModality.ValueType  # 5
    HEAD: _BiometricModality.ValueType  # 6
    BEHAVIOR: _BiometricModality.ValueType  # 7
    SOFT_BIOMETRICS: _BiometricModality.ValueType  # 8
    FINGERPRINT: _BiometricModality.ValueType  # 9
    IRIS: _BiometricModality.ValueType  # 10
    VOICE: _BiometricModality.ValueType  # 11
    HAND: _BiometricModality.ValueType  # 12
    EAR: _BiometricModality.ValueType  # 13
    PALM: _BiometricModality.ValueType  # 14
    OTHER: _BiometricModality.ValueType  # 15

class BiometricModality(_BiometricModality, metaclass=_BiometricModalityEnumTypeWrapper):
    """Used to specify general biometric modalities.  Typical BRIAR modalities fall into three categories: FACE, BODY, or GAIT.  UNSPECIFIED will typcially would be the fusion of all modalities."""

UNSPECIFIED: BiometricModality.ValueType  # 0
"""Use the fusion of all available modalities."""
WHOLE_BODY: BiometricModality.ValueType  # 1
"""deprecated.  Use BODY for general body appearance or features"""
FACE: BiometricModality.ValueType  # 2
GAIT: BiometricModality.ValueType  # 3
BODY: BiometricModality.ValueType  # 4
ANTHROPOMETRY: BiometricModality.ValueType  # 5
HEAD: BiometricModality.ValueType  # 6
BEHAVIOR: BiometricModality.ValueType  # 7
SOFT_BIOMETRICS: BiometricModality.ValueType  # 8
FINGERPRINT: BiometricModality.ValueType  # 9
IRIS: BiometricModality.ValueType  # 10
VOICE: BiometricModality.ValueType  # 11
HAND: BiometricModality.ValueType  # 12
EAR: BiometricModality.ValueType  # 13
PALM: BiometricModality.ValueType  # 14
OTHER: BiometricModality.ValueType  # 15
global___BiometricModality = BiometricModality

class _BriarDataType:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _BriarDataTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_BriarDataType.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    EMPTY: _BriarDataType.ValueType  # 0
    STRING: _BriarDataType.ValueType  # 1
    INT: _BriarDataType.ValueType  # 2
    """stored as string"""
    FLOAT: _BriarDataType.ValueType  # 3
    """stored as string"""
    BYTES: _BriarDataType.ValueType  # 4
    """raw data"""
    VECTOR: _BriarDataType.ValueType  # 5
    """floating point values seperated by commas"""
    PICKLE: _BriarDataType.ValueType  # 6
    XML: _BriarDataType.ValueType  # 7
    JSON: _BriarDataType.ValueType  # 8
    MATRIX: _BriarDataType.ValueType  # 9
    MEDIA: _BriarDataType.ValueType  # 11
    POINT: _BriarDataType.ValueType  # 12
    RECT: _BriarDataType.ValueType  # 13
    BUFFER: _BriarDataType.ValueType  # 14

class BriarDataType(_BriarDataType, metaclass=_BriarDataTypeEnumTypeWrapper):
    """----------------------------------------------------------------------------
    Data

    Enumeration for data types used by Briar
    """

EMPTY: BriarDataType.ValueType  # 0
STRING: BriarDataType.ValueType  # 1
INT: BriarDataType.ValueType  # 2
"""stored as string"""
FLOAT: BriarDataType.ValueType  # 3
"""stored as string"""
BYTES: BriarDataType.ValueType  # 4
"""raw data"""
VECTOR: BriarDataType.ValueType  # 5
"""floating point values seperated by commas"""
PICKLE: BriarDataType.ValueType  # 6
XML: BriarDataType.ValueType  # 7
JSON: BriarDataType.ValueType  # 8
MATRIX: BriarDataType.ValueType  # 9
MEDIA: BriarDataType.ValueType  # 11
POINT: BriarDataType.ValueType  # 12
RECT: BriarDataType.ValueType  # 13
BUFFER: BriarDataType.ValueType  # 14
global___BriarDataType = BriarDataType

class _FeatureVectorType:
    ValueType = typing.NewType("ValueType", builtins.int)
    V: typing_extensions.TypeAlias = ValueType

class _FeatureVectorTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[_FeatureVectorType.ValueType], builtins.type):
    DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
    BriarInt8: _FeatureVectorType.ValueType  # 0
    BriarInt16: _FeatureVectorType.ValueType  # 1
    BriarInt32: _FeatureVectorType.ValueType  # 2
    BriarInt64: _FeatureVectorType.ValueType  # 3
    BriarUInt8: _FeatureVectorType.ValueType  # 4
    BriarUInt16: _FeatureVectorType.ValueType  # 5
    BriarUInt32: _FeatureVectorType.ValueType  # 6
    BriarUInt64: _FeatureVectorType.ValueType  # 7
    BriarFloat: _FeatureVectorType.ValueType  # 8
    BriarDouble: _FeatureVectorType.ValueType  # 9

class FeatureVectorType(_FeatureVectorType, metaclass=_FeatureVectorTypeEnumTypeWrapper):
    """messages

    The data type of the feature vector returned by template_get_feature_vector
    """

BriarInt8: FeatureVectorType.ValueType  # 0
BriarInt16: FeatureVectorType.ValueType  # 1
BriarInt32: FeatureVectorType.ValueType  # 2
BriarInt64: FeatureVectorType.ValueType  # 3
BriarUInt8: FeatureVectorType.ValueType  # 4
BriarUInt16: FeatureVectorType.ValueType  # 5
BriarUInt32: FeatureVectorType.ValueType  # 6
BriarUInt64: FeatureVectorType.ValueType  # 7
BriarFloat: FeatureVectorType.ValueType  # 8
BriarDouble: FeatureVectorType.ValueType  # 9
global___FeatureVectorType = FeatureVectorType

@typing.final
class APIVersion(google.protobuf.message.Message):
    """----------------------------------------------------------------------------
    Versioning

    Query the implementation for the version
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MAJOR_FIELD_NUMBER: builtins.int
    MINOR_FIELD_NUMBER: builtins.int
    PATCH_FIELD_NUMBER: builtins.int
    major: builtins.int
    minor: builtins.int
    patch: builtins.int
    def __init__(
        self,
        *,
        major: builtins.int = ...,
        minor: builtins.int = ...,
        patch: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["major", b"major", "minor", b"minor", "patch", b"patch"]) -> None: ...

global___APIVersion = APIVersion

@typing.final
class StringOption(google.protobuf.message.Message):
    """----------------------------------------------------------------------------
    Options Primitives - These will indicate when default 
    values should be used and if an option is provided
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    OVERRIDE_DEFAULT_FIELD_NUMBER: builtins.int
    VALUE_FIELD_NUMBER: builtins.int
    override_default: builtins.bool
    value: builtins.str
    def __init__(
        self,
        *,
        override_default: builtins.bool = ...,
        value: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["override_default", b"override_default", "value", b"value"]) -> None: ...

global___StringOption = StringOption

@typing.final
class BoolOption(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    OVERRIDE_DEFAULT_FIELD_NUMBER: builtins.int
    VALUE_FIELD_NUMBER: builtins.int
    override_default: builtins.bool
    value: builtins.bool
    def __init__(
        self,
        *,
        override_default: builtins.bool = ...,
        value: builtins.bool = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["override_default", b"override_default", "value", b"value"]) -> None: ...

global___BoolOption = BoolOption

@typing.final
class IntOption(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    OVERRIDE_DEFAULT_FIELD_NUMBER: builtins.int
    VALUE_FIELD_NUMBER: builtins.int
    override_default: builtins.bool
    value: builtins.int
    def __init__(
        self,
        *,
        override_default: builtins.bool = ...,
        value: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["override_default", b"override_default", "value", b"value"]) -> None: ...

global___IntOption = IntOption

@typing.final
class FloatOption(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    OVERRIDE_DEFAULT_FIELD_NUMBER: builtins.int
    VALUE_FIELD_NUMBER: builtins.int
    override_default: builtins.bool
    value: builtins.float
    def __init__(
        self,
        *,
        override_default: builtins.bool = ...,
        value: builtins.float = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["override_default", b"override_default", "value", b"value"]) -> None: ...

global___FloatOption = FloatOption

@typing.final
class BriarMedia(google.protobuf.message.Message):
    """----------------------------------------------------------------------------
    Media
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    class _DataType:
        ValueType = typing.NewType("ValueType", builtins.int)
        V: typing_extensions.TypeAlias = ValueType

    class _DataTypeEnumTypeWrapper(google.protobuf.internal.enum_type_wrapper._EnumTypeWrapper[BriarMedia._DataType.ValueType], builtins.type):
        DESCRIPTOR: google.protobuf.descriptor.EnumDescriptor
        RGB8: BriarMedia._DataType.ValueType  # 0
        """Media data is expected to be returned to the API in this format, or MONO8"""
        MONO8: BriarMedia._DataType.ValueType  # 1
        """Media data is expected to be returned to the API in this format, or RGB8"""
        RGBA8: BriarMedia._DataType.ValueType  # 2
        RGBA16: BriarMedia._DataType.ValueType  # 3
        RGB16: BriarMedia._DataType.ValueType  # 4
        MONO16: BriarMedia._DataType.ValueType  # 5
        FLOAT32: BriarMedia._DataType.ValueType  # 6
        URL: BriarMedia._DataType.ValueType  # 7
        PNG: BriarMedia._DataType.ValueType  # 8
        """Lossless Compression"""
        JPG: BriarMedia._DataType.ValueType  # 9
        RAW: BriarMedia._DataType.ValueType  # 10
        EPS: BriarMedia._DataType.ValueType  # 11
        TIF: BriarMedia._DataType.ValueType  # 12
        GIF: BriarMedia._DataType.ValueType  # 13
        MP4: BriarMedia._DataType.ValueType  # 14
        MJPG: BriarMedia._DataType.ValueType  # 15
        H264: BriarMedia._DataType.ValueType  # 16
        H265: BriarMedia._DataType.ValueType  # 17
        GENERIC_IMAGE: BriarMedia._DataType.ValueType  # 18
        GENERIC_VIDEO: BriarMedia._DataType.ValueType  # 19
        SOURCE_ONLY: BriarMedia._DataType.ValueType  # 20
        """No media data is provided beyond the source location - this means it is up to the performer to load and decode the media"""

    class DataType(_DataType, metaclass=_DataTypeEnumTypeWrapper):
        """Enum to specify data encoding of the image data"""

    RGB8: BriarMedia.DataType.ValueType  # 0
    """Media data is expected to be returned to the API in this format, or MONO8"""
    MONO8: BriarMedia.DataType.ValueType  # 1
    """Media data is expected to be returned to the API in this format, or RGB8"""
    RGBA8: BriarMedia.DataType.ValueType  # 2
    RGBA16: BriarMedia.DataType.ValueType  # 3
    RGB16: BriarMedia.DataType.ValueType  # 4
    MONO16: BriarMedia.DataType.ValueType  # 5
    FLOAT32: BriarMedia.DataType.ValueType  # 6
    URL: BriarMedia.DataType.ValueType  # 7
    PNG: BriarMedia.DataType.ValueType  # 8
    """Lossless Compression"""
    JPG: BriarMedia.DataType.ValueType  # 9
    RAW: BriarMedia.DataType.ValueType  # 10
    EPS: BriarMedia.DataType.ValueType  # 11
    TIF: BriarMedia.DataType.ValueType  # 12
    GIF: BriarMedia.DataType.ValueType  # 13
    MP4: BriarMedia.DataType.ValueType  # 14
    MJPG: BriarMedia.DataType.ValueType  # 15
    H264: BriarMedia.DataType.ValueType  # 16
    H265: BriarMedia.DataType.ValueType  # 17
    GENERIC_IMAGE: BriarMedia.DataType.ValueType  # 18
    GENERIC_VIDEO: BriarMedia.DataType.ValueType  # 19
    SOURCE_ONLY: BriarMedia.DataType.ValueType  # 20
    """No media data is provided beyond the source location - this means it is up to the performer to load and decode the media"""

    WIDTH_FIELD_NUMBER: builtins.int
    HEIGHT_FIELD_NUMBER: builtins.int
    CHANNELS_FIELD_NUMBER: builtins.int
    FRAME_COUNT_FIELD_NUMBER: builtins.int
    FRAME_START_FIELD_NUMBER: builtins.int
    FRAME_END_FIELD_NUMBER: builtins.int
    FRAME_RATE_FIELD_NUMBER: builtins.int
    SEGMENT_ID_FIELD_NUMBER: builtins.int
    SEGMENT_TOTAL_FIELD_NUMBER: builtins.int
    FRAME_NUMBER_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    SOURCE_TYPE_FIELD_NUMBER: builtins.int
    DATA_FIELD_NUMBER: builtins.int
    SOURCE_FIELD_NUMBER: builtins.int
    SERVERSIDE_SOURCE_FIELD_NUMBER: builtins.int
    DESCRIPTION_FIELD_NUMBER: builtins.int
    DATETIME_FIELD_NUMBER: builtins.int
    ISCROPPED_FIELD_NUMBER: builtins.int
    METADATA_FIELD_NUMBER: builtins.int
    width: builtins.int
    """Width of img in px"""
    height: builtins.int
    """Height of img in px"""
    channels: builtins.int
    """Number of color layers"""
    frame_count: builtins.int
    """Number of frames in this media message"""
    frame_start: builtins.int
    """Start frame of media"""
    frame_end: builtins.int
    """End frame of media"""
    frame_rate: builtins.float
    """Framerate in frames/second"""
    segment_id: builtins.int
    """A number identifying the segment in a stream of media"""
    segment_total: builtins.int
    """A number specifying the total number of segments to expect.  A value of -1 indicates a continuous stream with an unknown end."""
    frame_number: builtins.int
    """If this is a single frame of a video, this denotes the frame number"""
    type: global___BriarMedia.DataType.ValueType
    """Data type of the media data"""
    source_type: global___BriarMedia.DataType.ValueType
    """Data type of the source of the media (e.g. if this is a frame of a video)"""
    data: builtins.bytes
    """Array of bytes containing media data. If raw color data it should be in RGB/RGBA order."""
    source: builtins.str
    """A string describing the source of the media (url,filepath,etc.)"""
    serverside_source: builtins.str
    """A string describing the media location if it presides on the server side (i.e. in a location that the performer's algorithm can access directly)"""
    description: builtins.str
    """Human friendly String to document image"""
    datetime: builtins.str
    """Optional: timestamp for tracking purposes"""
    isCropped: builtins.bool
    """Optional: A boolean to specify if the given media file is pre-cropped or full"""
    @property
    def metadata(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___MediaMetadata]:
        """Optional metadata for the entire media stream;"""

    def __init__(
        self,
        *,
        width: builtins.int = ...,
        height: builtins.int = ...,
        channels: builtins.int = ...,
        frame_count: builtins.int = ...,
        frame_start: builtins.int = ...,
        frame_end: builtins.int = ...,
        frame_rate: builtins.float = ...,
        segment_id: builtins.int = ...,
        segment_total: builtins.int = ...,
        frame_number: builtins.int = ...,
        type: global___BriarMedia.DataType.ValueType = ...,
        source_type: global___BriarMedia.DataType.ValueType = ...,
        data: builtins.bytes = ...,
        source: builtins.str = ...,
        serverside_source: builtins.str = ...,
        description: builtins.str = ...,
        datetime: builtins.str = ...,
        isCropped: builtins.bool = ...,
        metadata: collections.abc.Iterable[global___MediaMetadata] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["channels", b"channels", "data", b"data", "datetime", b"datetime", "description", b"description", "frame_count", b"frame_count", "frame_end", b"frame_end", "frame_number", b"frame_number", "frame_rate", b"frame_rate", "frame_start", b"frame_start", "height", b"height", "isCropped", b"isCropped", "metadata", b"metadata", "segment_id", b"segment_id", "segment_total", b"segment_total", "serverside_source", b"serverside_source", "source", b"source", "source_type", b"source_type", "type", b"type", "width", b"width"]) -> None: ...

global___BriarMedia = BriarMedia

@typing.final
class EnrollOptions(google.protobuf.message.Message):
    """messages

    Defines actions to take when enrolling into a gallery
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SAVE_METADATA_FIELD_NUMBER: builtins.int
    DEBUG_FIELD_NUMBER: builtins.int
    ENTRY_TYPE_FIELD_NUMBER: builtins.int
    SUBJECT_IDS_FIELD_NUMBER: builtins.int
    MEDIA_ID_FIELD_NUMBER: builtins.int
    ENROLL_BATCH_FIELD_NUMBER: builtins.int
    ENROLL_FLAG_FIELD_NUMBER: builtins.int
    MODALITY_FIELD_NUMBER: builtins.int
    RETURN_MEDIA_FIELD_NUMBER: builtins.int
    STORE_MEDIA_FIELD_NUMBER: builtins.int
    ATTRIBUTES_FIELD_NUMBER: builtins.int
    USE_SUBJECT_INTEGER_ID_FIELD_NUMBER: builtins.int
    SUBJECT_ID_INTEGER_FIELD_NUMBER: builtins.int
    entry_type: global___EntryType.ValueType
    """Type of entry, either 'subject' or 'media'"""
    media_id: builtins.str
    """ID of media this record belongs to (should be unique per record)"""
    enroll_flag: global___EnrollFlags.ValueType
    modality: global___BiometricModality.ValueType
    """Modality of enrollment (i.e. face or whole body)"""
    @property
    def save_metadata(self) -> global___BoolOption:
        """log the image on the server - Useful for debugging and record keeping"""

    @property
    def debug(self) -> global___BoolOption:
        """Save or print more info on the server side"""

    @property
    def subject_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """ID or list of IDs of subject(s) this record belongs to"""

    @property
    def enroll_batch(self) -> global___IntOption:
        """	string entry_id = 4;
        batch size for enrollment processes
        """

    @property
    def return_media(self) -> global___BoolOption:
        """Should we return media (e.i. cropped images) related to the detections back to the client?"""

    @property
    def store_media(self) -> global___BoolOption:
        """Should the database store the media along with templates for searching"""

    @property
    def attributes(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Attribute]:
        """Used for passing algorithm specific options"""

    @property
    def use_subject_integer_id(self) -> global___BoolOption:
        """DEPRICATED: FOR LEGACY SYSTEMS ONLY. Provides an integer-version of a subject ID"""

    @property
    def subject_id_integer(self) -> global___IntOption:
        """DEPRICATED: FOR LEGACY SYSTEMS ONLY. Provides an integer-version of a subject ID"""

    def __init__(
        self,
        *,
        save_metadata: global___BoolOption | None = ...,
        debug: global___BoolOption | None = ...,
        entry_type: global___EntryType.ValueType = ...,
        subject_ids: collections.abc.Iterable[builtins.str] | None = ...,
        media_id: builtins.str = ...,
        enroll_batch: global___IntOption | None = ...,
        enroll_flag: global___EnrollFlags.ValueType = ...,
        modality: global___BiometricModality.ValueType = ...,
        return_media: global___BoolOption | None = ...,
        store_media: global___BoolOption | None = ...,
        attributes: collections.abc.Iterable[global___Attribute] | None = ...,
        use_subject_integer_id: global___BoolOption | None = ...,
        subject_id_integer: global___IntOption | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["debug", b"debug", "enroll_batch", b"enroll_batch", "return_media", b"return_media", "save_metadata", b"save_metadata", "store_media", b"store_media", "subject_id_integer", b"subject_id_integer", "use_subject_integer_id", b"use_subject_integer_id"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["attributes", b"attributes", "debug", b"debug", "enroll_batch", b"enroll_batch", "enroll_flag", b"enroll_flag", "entry_type", b"entry_type", "media_id", b"media_id", "modality", b"modality", "return_media", b"return_media", "save_metadata", b"save_metadata", "store_media", b"store_media", "subject_id_integer", b"subject_id_integer", "subject_ids", b"subject_ids", "use_subject_integer_id", b"use_subject_integer_id"]) -> None: ...

global___EnrollOptions = EnrollOptions

@typing.final
class SearchOptions(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    OUT_DIR_FIELD_NUMBER: builtins.int
    OUTPUT_TYPE_FIELD_NUMBER: builtins.int
    SEARCH_DATABASE_FIELD_NUMBER: builtins.int
    PROBE_DATABASE_FIELD_NUMBER: builtins.int
    SEARCH_THRESHOLD_FIELD_NUMBER: builtins.int
    MAX_RESULTS_FIELD_NUMBER: builtins.int
    SEARCH_BATCH_FIELD_NUMBER: builtins.int
    USE_DETECTIONS_FIELD_NUMBER: builtins.int
    USE_TEMPLATES_FIELD_NUMBER: builtins.int
    FLAG_FIELD_NUMBER: builtins.int
    RETURN_MEDIA_FIELD_NUMBER: builtins.int
    MODALITY_FIELD_NUMBER: builtins.int
    FULL_FIELD_NUMBER: builtins.int
    RETURN_MATRIX_FIELD_NUMBER: builtins.int
    flag: global___SearchFlags.ValueType
    modality: global___BiometricModality.ValueType
    """REQUIRED: If specified use this modality for search operations.  If "UNSPECIFIED" fuse modalities together."""
    @property
    def out_dir(self) -> global___StringOption:
        """Defines options to use for search operations.
        DEPRICATED: not needed on server side. Save the search results as a CSV
        """

    @property
    def output_type(self) -> global___StringOption:
        """DEPRICATED: ???. Output the search logs"""

    @property
    def search_database(self) -> global___StringOption:
        """DEPRICATED: Already in search request. The database name to be used as the gallery/search database"""

    @property
    def probe_database(self) -> global___StringOption:
        """DEPRICATED: Already in search request. The database name to be used as the probe database (if none, it will not be used)"""

    @property
    def search_threshold(self) -> global___FloatOption:
        """OPTIONAL: Exclude search results below this threshold. Server should select a reasonable default if missing."""

    @property
    def max_results(self) -> global___IntOption:
        """OPTIONAL: Maximum number of results per probe."""

    @property
    def search_batch(self) -> global___IntOption:
        """DEPRICATED: ???. batch size for search processes"""

    @property
    def use_detections(self) -> global___BoolOption: ...
    @property
    def use_templates(self) -> global___BoolOption: ...
    @property
    def return_media(self) -> global___BoolOption:
        """OPTIONAL: Should we return media (e.i. cropped images) related to the detections back to the client?"""

    @property
    def full(self) -> global___BoolOption:
        """OPTIONAL: to perform a full MxN search instead of a K-core search"""

    @property
    def return_matrix(self) -> global___BoolOption:
        """OPTIONAL: to return the search matrix instead matchresults"""

    def __init__(
        self,
        *,
        out_dir: global___StringOption | None = ...,
        output_type: global___StringOption | None = ...,
        search_database: global___StringOption | None = ...,
        probe_database: global___StringOption | None = ...,
        search_threshold: global___FloatOption | None = ...,
        max_results: global___IntOption | None = ...,
        search_batch: global___IntOption | None = ...,
        use_detections: global___BoolOption | None = ...,
        use_templates: global___BoolOption | None = ...,
        flag: global___SearchFlags.ValueType = ...,
        return_media: global___BoolOption | None = ...,
        modality: global___BiometricModality.ValueType = ...,
        full: global___BoolOption | None = ...,
        return_matrix: global___BoolOption | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["full", b"full", "max_results", b"max_results", "out_dir", b"out_dir", "output_type", b"output_type", "probe_database", b"probe_database", "return_matrix", b"return_matrix", "return_media", b"return_media", "search_batch", b"search_batch", "search_database", b"search_database", "search_threshold", b"search_threshold", "use_detections", b"use_detections", "use_templates", b"use_templates"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["flag", b"flag", "full", b"full", "max_results", b"max_results", "modality", b"modality", "out_dir", b"out_dir", "output_type", b"output_type", "probe_database", b"probe_database", "return_matrix", b"return_matrix", "return_media", b"return_media", "search_batch", b"search_batch", "search_database", b"search_database", "search_threshold", b"search_threshold", "use_detections", b"use_detections", "use_templates", b"use_templates"]) -> None: ...

global___SearchOptions = SearchOptions

@typing.final
class VerifyOptions(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DEBUG_FIELD_NUMBER: builtins.int
    USE_DETECTIONS_FIELD_NUMBER: builtins.int
    USE_TEMPLATES_FIELD_NUMBER: builtins.int
    USE_WHOLE_IMAGE_FIELD_NUMBER: builtins.int
    FLAG_FIELD_NUMBER: builtins.int
    RETURN_MEDIA_FIELD_NUMBER: builtins.int
    MODALITY_FIELD_NUMBER: builtins.int
    flag: global___VerifyFlags.ValueType
    modality: global___BiometricModality.ValueType
    """REQUIRED: If specified use this modality for search operations.  If "UNSPECIFIED" fuse modalities together."""
    @property
    def debug(self) -> global___BoolOption:
        """Defines options to use for search operations."""

    @property
    def use_detections(self) -> global___BoolOption: ...
    @property
    def use_templates(self) -> global___BoolOption: ...
    @property
    def use_whole_image(self) -> global___BoolOption: ...
    @property
    def return_media(self) -> global___BoolOption:
        """OPTIONAL: Should we return media (e.i. cropped images) related to the detections back to the client?"""

    def __init__(
        self,
        *,
        debug: global___BoolOption | None = ...,
        use_detections: global___BoolOption | None = ...,
        use_templates: global___BoolOption | None = ...,
        use_whole_image: global___BoolOption | None = ...,
        flag: global___VerifyFlags.ValueType = ...,
        return_media: global___BoolOption | None = ...,
        modality: global___BiometricModality.ValueType = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["debug", b"debug", "return_media", b"return_media", "use_detections", b"use_detections", "use_templates", b"use_templates", "use_whole_image", b"use_whole_image"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["debug", b"debug", "flag", b"flag", "modality", b"modality", "return_media", b"return_media", "use_detections", b"use_detections", "use_templates", b"use_templates", "use_whole_image", b"use_whole_image"]) -> None: ...

global___VerifyOptions = VerifyOptions

@typing.final
class BriarRect(google.protobuf.message.Message):
    """messages

    TODO optionally break this out into briar_geometry.proto
    message to hold rectangle
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    X_FIELD_NUMBER: builtins.int
    Y_FIELD_NUMBER: builtins.int
    WIDTH_FIELD_NUMBER: builtins.int
    HEIGHT_FIELD_NUMBER: builtins.int
    x: builtins.int
    """Upper left corner"""
    y: builtins.int
    """Upper left corner"""
    width: builtins.int
    """x distance to lower right corner"""
    height: builtins.int
    """y distance to lower right corner"""
    def __init__(
        self,
        *,
        x: builtins.int = ...,
        y: builtins.int = ...,
        width: builtins.int = ...,
        height: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["height", b"height", "width", b"width", "x", b"x", "y", b"y"]) -> None: ...

global___BriarRect = BriarRect

@typing.final
class BriarPoint2D(google.protobuf.message.Message):
    """message to hold a point"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    X_FIELD_NUMBER: builtins.int
    Y_FIELD_NUMBER: builtins.int
    x: builtins.float
    y: builtins.float
    def __init__(
        self,
        *,
        x: builtins.float = ...,
        y: builtins.float = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["x", b"x", "y", b"y"]) -> None: ...

global___BriarPoint2D = BriarPoint2D

@typing.final
class BriarProgress(google.protobuf.message.Message):
    """message that contains progress"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    CURRENTSTEP_FIELD_NUMBER: builtins.int
    TOTALSTEPS_FIELD_NUMBER: builtins.int
    currentStep: builtins.int
    """The current step that the process is on"""
    totalSteps: builtins.int
    """The total steps that the process has to complete (i.e. frames in a video)"""
    def __init__(
        self,
        *,
        currentStep: builtins.int = ...,
        totalSteps: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["currentStep", b"currentStep", "totalSteps", b"totalSteps"]) -> None: ...

global___BriarProgress = BriarProgress

@typing.final
class BriarVector(google.protobuf.message.Message):
    """message to hold a vector"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DATA_FIELD_NUMBER: builtins.int
    @property
    def data(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
        """arbitrary length array to store vector"""

    def __init__(
        self,
        *,
        data: collections.abc.Iterable[builtins.float] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["data", b"data"]) -> None: ...

global___BriarVector = BriarVector

@typing.final
class BriarMatrix(google.protobuf.message.Message):
    """message to hold a vector of vectors"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    COLUMN_HEADERS_FIELD_NUMBER: builtins.int
    ROW_HEADERS_FIELD_NUMBER: builtins.int
    COLUMN_HEADERS_INTEGER_FIELD_NUMBER: builtins.int
    ROW_HEADERS_INTEGER_FIELD_NUMBER: builtins.int
    COLUMN_SOURCES_FIELD_NUMBER: builtins.int
    ROW_SOURCES_FIELD_NUMBER: builtins.int
    COLUMN_ATTRIBUTES_FIELD_NUMBER: builtins.int
    ROW_ATTRIBUTES_FIELD_NUMBER: builtins.int
    ROWS_FIELD_NUMBER: builtins.int
    @property
    def column_headers(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """Optional: headers for each column"""

    @property
    def row_headers(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """Optional: headers for each row"""

    @property
    def column_headers_integer(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """Optional: integer headers for each column"""

    @property
    def row_headers_integer(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """Optional: integer headers for each row"""

    @property
    def column_sources(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """Optional: sources for each column"""

    @property
    def row_sources(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """Optional: sources for each row"""

    @property
    def column_attributes(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Attribute]: ...
    @property
    def row_attributes(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Attribute]: ...
    @property
    def rows(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___BriarVector]:
        """arbitrary length array of vectors to store row"""

    def __init__(
        self,
        *,
        column_headers: collections.abc.Iterable[builtins.str] | None = ...,
        row_headers: collections.abc.Iterable[builtins.str] | None = ...,
        column_headers_integer: collections.abc.Iterable[builtins.int] | None = ...,
        row_headers_integer: collections.abc.Iterable[builtins.int] | None = ...,
        column_sources: collections.abc.Iterable[builtins.str] | None = ...,
        row_sources: collections.abc.Iterable[builtins.str] | None = ...,
        column_attributes: collections.abc.Iterable[global___Attribute] | None = ...,
        row_attributes: collections.abc.Iterable[global___Attribute] | None = ...,
        rows: collections.abc.Iterable[global___BriarVector] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["column_attributes", b"column_attributes", "column_headers", b"column_headers", "column_headers_integer", b"column_headers_integer", "column_sources", b"column_sources", "row_attributes", b"row_attributes", "row_headers", b"row_headers", "row_headers_integer", b"row_headers_integer", "row_sources", b"row_sources", "rows", b"rows"]) -> None: ...

global___BriarMatrix = BriarMatrix

@typing.final
class Attribute(google.protobuf.message.Message):
    """This is intended to support flexible encoding schemes in a dictionary like messageure:
    Example encodings: MALE:0.975; AGE:35.2; RACE:WHITE

    Typically populate only one of the following values: bytes, fvalue, ivalue, text pickle, json
    matrix vector image point rect xml
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    DESCRIPTION_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    BUFFER_FIELD_NUMBER: builtins.int
    FVALUE_FIELD_NUMBER: builtins.int
    IVALUE_FIELD_NUMBER: builtins.int
    TEXT_FIELD_NUMBER: builtins.int
    PICKLE_FIELD_NUMBER: builtins.int
    JSON_FIELD_NUMBER: builtins.int
    MATRIX_FIELD_NUMBER: builtins.int
    VECTOR_FIELD_NUMBER: builtins.int
    MEDIA_FIELD_NUMBER: builtins.int
    POINT_FIELD_NUMBER: builtins.int
    RECT_FIELD_NUMBER: builtins.int
    XML_FIELD_NUMBER: builtins.int
    key: builtins.str
    """uid for this attribute"""
    description: builtins.str
    """A text description on the content or type hint"""
    type: global___BriarDataType.ValueType
    buffer: builtins.bytes
    fvalue: builtins.float
    ivalue: builtins.int
    text: builtins.str
    pickle: builtins.bytes
    json: builtins.bytes
    xml: builtins.bytes
    @property
    def matrix(self) -> global___BriarMatrix: ...
    @property
    def vector(self) -> global___BriarVector: ...
    @property
    def media(self) -> global___BriarMedia: ...
    @property
    def point(self) -> global___BriarPoint2D: ...
    @property
    def rect(self) -> global___BriarRect: ...
    def __init__(
        self,
        *,
        key: builtins.str = ...,
        description: builtins.str = ...,
        type: global___BriarDataType.ValueType = ...,
        buffer: builtins.bytes = ...,
        fvalue: builtins.float = ...,
        ivalue: builtins.int = ...,
        text: builtins.str = ...,
        pickle: builtins.bytes = ...,
        json: builtins.bytes = ...,
        matrix: global___BriarMatrix | None = ...,
        vector: global___BriarVector | None = ...,
        media: global___BriarMedia | None = ...,
        point: global___BriarPoint2D | None = ...,
        rect: global___BriarRect | None = ...,
        xml: builtins.bytes = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["matrix", b"matrix", "media", b"media", "point", b"point", "rect", b"rect", "vector", b"vector"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["buffer", b"buffer", "description", b"description", "fvalue", b"fvalue", "ivalue", b"ivalue", "json", b"json", "key", b"key", "matrix", b"matrix", "media", b"media", "pickle", b"pickle", "point", b"point", "rect", b"rect", "text", b"text", "type", b"type", "vector", b"vector", "xml", b"xml"]) -> None: ...

global___Attribute = Attribute

@typing.final
class FrameMetadata(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ATTRIBUTES_FIELD_NUMBER: builtins.int
    @property
    def attributes(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Attribute]: ...
    def __init__(
        self,
        *,
        attributes: collections.abc.Iterable[global___Attribute] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["attributes", b"attributes"]) -> None: ...

global___FrameMetadata = FrameMetadata

@typing.final
class MediaMetadata(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ATTRIBUTES_FIELD_NUMBER: builtins.int
    FRAME_METADATA_FIELD_NUMBER: builtins.int
    @property
    def attributes(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Attribute]:
        """metadata describing the full media object"""

    @property
    def frame_metadata(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___FrameMetadata]:
        """metadata objects associated at a frame by frame level"""

    def __init__(
        self,
        *,
        attributes: collections.abc.Iterable[global___Attribute] | None = ...,
        frame_metadata: collections.abc.Iterable[global___FrameMetadata] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["attributes", b"attributes", "frame_metadata", b"frame_metadata"]) -> None: ...

global___MediaMetadata = MediaMetadata

@typing.final
class Detection(google.protobuf.message.Message):
    """Data relating to the detection of an object in an image.  Tracklet_id should be associate with a single person which may contain multiple detections for many modalities (head, body, hands, etc) and result in a single multimodal template."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    CONFIDENCE_FIELD_NUMBER: builtins.int
    LOCATION_FIELD_NUMBER: builtins.int
    FRAME_FIELD_NUMBER: builtins.int
    DETECTION_ID_FIELD_NUMBER: builtins.int
    TRACKLET_ID_FIELD_NUMBER: builtins.int
    DETECTION_CLASS_FIELD_NUMBER: builtins.int
    MODALITY_FIELD_NUMBER: builtins.int
    ATTRIBUTES_FIELD_NUMBER: builtins.int
    MASK_FIELD_NUMBER: builtins.int
    MEDIA_FIELD_NUMBER: builtins.int
    confidence: builtins.float
    """RECOMMENDED: Confidence of detection"""
    frame: builtins.int
    """RECOMMENDED: Frame number associated with the detection"""
    detection_id: builtins.int
    """RECOMMENDED: unique id of detection"""
    tracklet_id: builtins.int
    """RECOMMENDED: the id of a tracklet for this media"""
    detection_class: builtins.str
    """DEPRICATED: use modality or attributes instead"""
    modality: global___BiometricModality.ValueType
    """RECOMMENDED: modality associated with this detection."""
    @property
    def location(self) -> global___BriarRect:
        """REQUIRED: Bounding Box of detection"""

    @property
    def attributes(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Attribute]:
        """OPTIONAL: attributes describing the detection"""

    @property
    def mask(self) -> global___BriarMedia:
        """DEPRICATED: use attributes instead - a mask pertaining to the segmented object detected"""

    @property
    def media(self) -> global___BriarMedia:
        """DEPRICATED: use attributes instead - data pertaining to the detection (i.e. an optional image)"""

    def __init__(
        self,
        *,
        confidence: builtins.float = ...,
        location: global___BriarRect | None = ...,
        frame: builtins.int = ...,
        detection_id: builtins.int = ...,
        tracklet_id: builtins.int = ...,
        detection_class: builtins.str = ...,
        modality: global___BiometricModality.ValueType = ...,
        attributes: collections.abc.Iterable[global___Attribute] | None = ...,
        mask: global___BriarMedia | None = ...,
        media: global___BriarMedia | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["location", b"location", "mask", b"mask", "media", b"media"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["attributes", b"attributes", "confidence", b"confidence", "detection_class", b"detection_class", "detection_id", b"detection_id", "frame", b"frame", "location", b"location", "mask", b"mask", "media", b"media", "modality", b"modality", "tracklet_id", b"tracklet_id"]) -> None: ...

global___Detection = Detection

@typing.final
class Tracklet(google.protobuf.message.Message):
    """Represents a time-wise track of a detected instance"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DETECTIONS_FIELD_NUMBER: builtins.int
    ATTRIBUTES_FIELD_NUMBER: builtins.int
    TRACKLET_CLASS_FIELD_NUMBER: builtins.int
    TRACKLET_ID_FIELD_NUMBER: builtins.int
    OPTIONS_FIELD_NUMBER: builtins.int
    tracklet_class: builtins.str
    """DEPRICATED: use modality or attributes instead. defines type of tracklet (body, face, features, etc...)"""
    tracklet_id: builtins.int
    """the id of a tracklet for this media"""
    @property
    def detections(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Detection]:
        """REQUIRED: the set of detections defining the tracklet"""

    @property
    def attributes(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Attribute]:
        """OPTIONAL: attributes describing the tracklet"""

    @property
    def options(self) -> global___TrackingOptions:
        """OPTIONAL: persistent options used to call the tracker"""

    def __init__(
        self,
        *,
        detections: collections.abc.Iterable[global___Detection] | None = ...,
        attributes: collections.abc.Iterable[global___Attribute] | None = ...,
        tracklet_class: builtins.str = ...,
        tracklet_id: builtins.int = ...,
        options: global___TrackingOptions | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["options", b"options"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["attributes", b"attributes", "detections", b"detections", "options", b"options", "tracklet_class", b"tracklet_class", "tracklet_id", b"tracklet_id"]) -> None: ...

global___Tracklet = Tracklet

@typing.final
class DetectionOptions(google.protobuf.message.Message):
    """Configuration for the detection algorithm"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ALGORITHM_ID_FIELD_NUMBER: builtins.int
    BEST_FIELD_NUMBER: builtins.int
    FACE_THRESHOLD_FIELD_NUMBER: builtins.int
    BODY_THRESHOLD_FIELD_NUMBER: builtins.int
    FACE_MIN_HEIGHT_FIELD_NUMBER: builtins.int
    BODY_MIN_HEIGHT_FIELD_NUMBER: builtins.int
    DETECT_BATCH_FIELD_NUMBER: builtins.int
    ENABLE_METADATA_FIELD_NUMBER: builtins.int
    DEBUG_FIELD_NUMBER: builtins.int
    RETURN_MEDIA_FIELD_NUMBER: builtins.int
    TRACKING_OPTIONS_FIELD_NUMBER: builtins.int
    MODALITY_FIELD_NUMBER: builtins.int
    ATTRIBUTES_FIELD_NUMBER: builtins.int
    modality: global___BiometricModality.ValueType
    """Whether detection is for face or whole body"""
    @property
    def algorithm_id(self) -> global___StringOption:
        """uid corresponding to which algorithm to use"""

    @property
    def best(self) -> global___BoolOption:
        """only respond with the best candidates"""

    @property
    def face_threshold(self) -> global___FloatOption:
        """min score for candidate consideration"""

    @property
    def body_threshold(self) -> global___FloatOption:
        """min score for candidate consideration"""

    @property
    def face_min_height(self) -> global___IntOption:
        """min size for a face detection to be considered"""

    @property
    def body_min_height(self) -> global___IntOption:
        """min size for a body detection to be considered"""

    @property
    def detect_batch(self) -> global___IntOption:
        """batch size for detection processes"""

    @property
    def enable_metadata(self) -> global___BoolOption:
        """extract additional metadata and attributes (landmarks, pose, demographics, etc)"""

    @property
    def debug(self) -> global___BoolOption:
        """Save or print more info on the server side"""

    @property
    def return_media(self) -> global___BoolOption:
        """Should we return media (e.i. cropped images) related to the detections back to the client?"""

    @property
    def tracking_options(self) -> global___TrackingOptions:
        """Configure tracking"""

    @property
    def attributes(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Attribute]:
        """Used for passing algorithm specific or custom options"""

    def __init__(
        self,
        *,
        algorithm_id: global___StringOption | None = ...,
        best: global___BoolOption | None = ...,
        face_threshold: global___FloatOption | None = ...,
        body_threshold: global___FloatOption | None = ...,
        face_min_height: global___IntOption | None = ...,
        body_min_height: global___IntOption | None = ...,
        detect_batch: global___IntOption | None = ...,
        enable_metadata: global___BoolOption | None = ...,
        debug: global___BoolOption | None = ...,
        return_media: global___BoolOption | None = ...,
        tracking_options: global___TrackingOptions | None = ...,
        modality: global___BiometricModality.ValueType = ...,
        attributes: collections.abc.Iterable[global___Attribute] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["algorithm_id", b"algorithm_id", "best", b"best", "body_min_height", b"body_min_height", "body_threshold", b"body_threshold", "debug", b"debug", "detect_batch", b"detect_batch", "enable_metadata", b"enable_metadata", "face_min_height", b"face_min_height", "face_threshold", b"face_threshold", "return_media", b"return_media", "tracking_options", b"tracking_options"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["algorithm_id", b"algorithm_id", "attributes", b"attributes", "best", b"best", "body_min_height", b"body_min_height", "body_threshold", b"body_threshold", "debug", b"debug", "detect_batch", b"detect_batch", "enable_metadata", b"enable_metadata", "face_min_height", b"face_min_height", "face_threshold", b"face_threshold", "modality", b"modality", "return_media", b"return_media", "tracking_options", b"tracking_options"]) -> None: ...

global___DetectionOptions = DetectionOptions

@typing.final
class TrackingOptions(google.protobuf.message.Message):
    """Configuration for the tracking algorithms"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ALGORITHM_ID_FIELD_NUMBER: builtins.int
    TRACKING_DISABLE_FIELD_NUMBER: builtins.int
    THRESHOLD_FIELD_NUMBER: builtins.int
    TRACKING_BATCH_FIELD_NUMBER: builtins.int
    RETURN_MEDIA_FIELD_NUMBER: builtins.int
    MODALITY_FIELD_NUMBER: builtins.int
    ATTRIBUTES_FIELD_NUMBER: builtins.int
    modality: global___BiometricModality.ValueType
    """Whether tracking is for face or whole body"""
    @property
    def algorithm_id(self) -> global___StringOption:
        """uid corresponding to which algorithm to use"""

    @property
    def tracking_disable(self) -> global___BoolOption:
        """min score for candidate consideration"""

    @property
    def threshold(self) -> global___FloatOption:
        """min score for candidate consideration"""

    @property
    def tracking_batch(self) -> global___IntOption:
        """batch size for tracking processes"""

    @property
    def return_media(self) -> global___BoolOption:
        """FloatOption encoding = 4;
        Should we return media (e.i. cropped image set) related to the tracklets back to the client?
        """

    @property
    def attributes(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Attribute]:
        """Used for passing algorithm specific or custom options"""

    def __init__(
        self,
        *,
        algorithm_id: global___StringOption | None = ...,
        tracking_disable: global___BoolOption | None = ...,
        threshold: global___FloatOption | None = ...,
        tracking_batch: global___IntOption | None = ...,
        return_media: global___BoolOption | None = ...,
        modality: global___BiometricModality.ValueType = ...,
        attributes: collections.abc.Iterable[global___Attribute] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["algorithm_id", b"algorithm_id", "return_media", b"return_media", "threshold", b"threshold", "tracking_batch", b"tracking_batch", "tracking_disable", b"tracking_disable"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["algorithm_id", b"algorithm_id", "attributes", b"attributes", "modality", b"modality", "return_media", b"return_media", "threshold", b"threshold", "tracking_batch", b"tracking_batch", "tracking_disable", b"tracking_disable"]) -> None: ...

global___TrackingOptions = TrackingOptions

@typing.final
class EnhanceOptions(google.protobuf.message.Message):
    """Configuration for the detection algorithm"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ALGORITHM_ID_FIELD_NUMBER: builtins.int
    RETURN_MEDIA_FIELD_NUMBER: builtins.int
    ENHANCE_BATCH_FIELD_NUMBER: builtins.int
    MODALITY_FIELD_NUMBER: builtins.int
    CROPPED_FIELD_NUMBER: builtins.int
    ATTRIBUTES_FIELD_NUMBER: builtins.int
    modality: global___BiometricModality.ValueType
    """Whether detection is for face or whole body"""
    cropped: builtins.bool
    @property
    def algorithm_id(self) -> global___StringOption:
        """uid corresponding to which algorithm to use"""

    @property
    def return_media(self) -> global___BoolOption:
        """Should we return media (e.i. cropped images) related to the detections back to the client?"""

    @property
    def enhance_batch(self) -> global___IntOption:
        """batch size for enhancement processes"""

    @property
    def attributes(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Attribute]:
        """Used for passing algorithm specific or custom options"""

    def __init__(
        self,
        *,
        algorithm_id: global___StringOption | None = ...,
        return_media: global___BoolOption | None = ...,
        enhance_batch: global___IntOption | None = ...,
        modality: global___BiometricModality.ValueType = ...,
        cropped: builtins.bool = ...,
        attributes: collections.abc.Iterable[global___Attribute] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["algorithm_id", b"algorithm_id", "enhance_batch", b"enhance_batch", "return_media", b"return_media"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["algorithm_id", b"algorithm_id", "attributes", b"attributes", "cropped", b"cropped", "enhance_batch", b"enhance_batch", "modality", b"modality", "return_media", b"return_media"]) -> None: ...

global___EnhanceOptions = EnhanceOptions

@typing.final
class ExtractOptions(google.protobuf.message.Message):
    """Options to extract a detected subject from an image"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ALGORITHM_ID_FIELD_NUMBER: builtins.int
    DEBUG_FIELD_NUMBER: builtins.int
    FLAG_FIELD_NUMBER: builtins.int
    EXTRACT_BATCH_FIELD_NUMBER: builtins.int
    MODALITY_FIELD_NUMBER: builtins.int
    RETURN_MEDIA_FIELD_NUMBER: builtins.int
    ATTRIBUTES_FIELD_NUMBER: builtins.int
    flag: global___ExtractFlags.ValueType
    """Flags to allow for auto-detection"""
    modality: global___BiometricModality.ValueType
    """Specifies extraction for a specific modality (i.e. face or whole body)"""
    @property
    def algorithm_id(self) -> global___StringOption: ...
    @property
    def debug(self) -> global___BoolOption:
        """Save or print more info on the server side"""

    @property
    def extract_batch(self) -> global___IntOption:
        """batch size for extraction processes"""

    @property
    def return_media(self) -> global___BoolOption:
        """Should we return media (e.i. cropped images) related to the detections back to the client?"""

    @property
    def attributes(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Attribute]:
        """Used for passing algorithm specific options"""

    def __init__(
        self,
        *,
        algorithm_id: global___StringOption | None = ...,
        debug: global___BoolOption | None = ...,
        flag: global___ExtractFlags.ValueType = ...,
        extract_batch: global___IntOption | None = ...,
        modality: global___BiometricModality.ValueType = ...,
        return_media: global___BoolOption | None = ...,
        attributes: collections.abc.Iterable[global___Attribute] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["algorithm_id", b"algorithm_id", "debug", b"debug", "extract_batch", b"extract_batch", "return_media", b"return_media"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["algorithm_id", b"algorithm_id", "attributes", b"attributes", "debug", b"debug", "extract_batch", b"extract_batch", "flag", b"flag", "modality", b"modality", "return_media", b"return_media"]) -> None: ...

global___ExtractOptions = ExtractOptions

@typing.final
class TemplateImageInput(google.protobuf.message.Message):
    """messages
    Landmarks such as facial features detected by Briar
    message BriarLandmark_delete {
    	string landmark_id = 1;     // Uid of landmark
    	BriarPoint2D location = 2;  // Point location of landmark
    };

    Data structure to keep image data and detections together
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    IM_FIELD_NUMBER: builtins.int
    DETECTIONS_FIELD_NUMBER: builtins.int
    @property
    def im(self) -> global___BriarMedia: ...
    @property
    def detections(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___BriarRect]: ...
    def __init__(
        self,
        *,
        im: global___BriarMedia | None = ...,
        detections: collections.abc.Iterable[global___BriarRect] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["im", b"im"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["detections", b"detections", "im", b"im"]) -> None: ...

global___TemplateImageInput = TemplateImageInput

@typing.final
class TemplateData(google.protobuf.message.Message):
    """Mapping item to store a simple part of multipart/multimodal templates.  The message contains mostly optional header and then algorithms will typically use just one data format (buffer, matrix, vector, etc.) to encode the associated signature data. Attributes can be used to store additional data as needed, i.e. yaw_angle, pitch_angle, resolution."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    KEY_FIELD_NUMBER: builtins.int
    DESCRIPTION_FIELD_NUMBER: builtins.int
    MODALITY_FIELD_NUMBER: builtins.int
    SUBMODALITY_FIELD_NUMBER: builtins.int
    SOURCE_ID_FIELD_NUMBER: builtins.int
    TRACKLET_ID_FIELD_NUMBER: builtins.int
    METADATA_FIELD_NUMBER: builtins.int
    key: builtins.str
    """REQUIRED: unique id for this data"""
    description: builtins.str
    """OPTIONAL: A text description on the content or type hint"""
    modality: global___BiometricModality.ValueType
    """RECOMMENDED: Biometric signature captured in the template"""
    submodality: builtins.str
    """OPTIONAL: more detail on the type of modality or signature if needed"""
    source_id: builtins.str
    """OPTIONAL: Link back to the media source of this data"""
    tracklet_id: builtins.str
    """OPTIONAL: Link back to the tracklet or detection associated with this data"""
    @property
    def metadata(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Attribute]:
        """OPTIONAL: Unstructured mapping to store additional data about the record as needed."""

    def __init__(
        self,
        *,
        key: builtins.str = ...,
        description: builtins.str = ...,
        modality: global___BiometricModality.ValueType = ...,
        submodality: builtins.str = ...,
        source_id: builtins.str = ...,
        tracklet_id: builtins.str = ...,
        metadata: collections.abc.Iterable[global___Attribute] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["description", b"description", "key", b"key", "metadata", b"metadata", "modality", b"modality", "source_id", b"source_id", "submodality", b"submodality", "tracklet_id", b"tracklet_id"]) -> None: ...

global___TemplateData = TemplateData

@typing.final
class Template(google.protobuf.message.Message):
    """Data structure to hold signature generated from an extraction. Typically just populate one of "parts", "data", or "buffer"."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    ID_FIELD_NUMBER: builtins.int
    ASSOCIATED_DETECTION_ID_FIELD_NUMBER: builtins.int
    ASSOCIATED_TRACKLET_ID_FIELD_NUMBER: builtins.int
    ALGORITHM_FIELD_NUMBER: builtins.int
    PARTS_FIELD_NUMBER: builtins.int
    DATA_FIELD_NUMBER: builtins.int
    BUFFER_FIELD_NUMBER: builtins.int
    METADATA_FIELD_NUMBER: builtins.int
    MODALITY_FIELD_NUMBER: builtins.int
    id: builtins.str
    """REQUIRED: String identifier associated with template."""
    associated_detection_id: builtins.int
    """REQUIRED: The detection ID that this template is associated to"""
    associated_tracklet_id: builtins.int
    """REQUIRED: The tracklet ID that this template is associated to, if only detections are used leave this blank"""
    algorithm: builtins.str
    """OPTIONAL: Document which algorithm or machine learning model was used to create the signature vector."""
    buffer: builtins.bytes
    """OPTIONAL: General storage.  Can be used for raw binary data templates or proprietary formats."""
    modality: global___BiometricModality.ValueType
    @property
    def parts(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___TemplateData]:
        """RECOMMENDED: Mapping to store multipart or multiple modality templates."""

    @property
    def data(self) -> global___BriarVector:
        """OPTIONAL: Simple templates can use a standard floating point feature vector."""

    @property
    def metadata(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Attribute]:
        """OPTIONAL: Unstructured mapping to store additional data about the record as needed."""

    def __init__(
        self,
        *,
        id: builtins.str = ...,
        associated_detection_id: builtins.int = ...,
        associated_tracklet_id: builtins.int = ...,
        algorithm: builtins.str = ...,
        parts: collections.abc.Iterable[global___TemplateData] | None = ...,
        data: global___BriarVector | None = ...,
        buffer: builtins.bytes = ...,
        metadata: collections.abc.Iterable[global___Attribute] | None = ...,
        modality: global___BiometricModality.ValueType = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["data", b"data"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["algorithm", b"algorithm", "associated_detection_id", b"associated_detection_id", "associated_tracklet_id", b"associated_tracklet_id", "buffer", b"buffer", "data", b"data", "id", b"id", "metadata", b"metadata", "modality", b"modality", "parts", b"parts"]) -> None: ...

global___Template = Template

@typing.final
class TemplateList(google.protobuf.message.Message):
    """List of template"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    TMPLS_FIELD_NUMBER: builtins.int
    @property
    def tmpls(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Template]:
        """List of Templates"""

    def __init__(
        self,
        *,
        tmpls: collections.abc.Iterable[global___Template] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["tmpls", b"tmpls"]) -> None: ...

global___TemplateList = TemplateList

@typing.final
class TemplateListGroup(google.protobuf.message.Message):
    """List of List of templates"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    GROUP_FIELD_NUMBER: builtins.int
    @property
    def group(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___TemplateList]:
        """List of List of templates"""

    def __init__(
        self,
        *,
        group: collections.abc.Iterable[global___TemplateList] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["group", b"group"]) -> None: ...

global___TemplateListGroup = TemplateListGroup

@typing.final
class EnrollmentInfo(google.protobuf.message.Message):
    """Information about the entity being enrolled"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DATABASE_ID_FIELD_NUMBER: builtins.int
    MEDIA_ID_FIELD_NUMBER: builtins.int
    SUBJECT_ID_FIELD_NUMBER: builtins.int
    TYPE_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    SOURCE_FIELD_NUMBER: builtins.int
    ATTRIBUTES_FIELD_NUMBER: builtins.int
    database_id: builtins.str
    """uuid for this database"""
    media_id: builtins.str
    """	string entry_id = 2;         // uuid for this entry (this is unique, typically subject_id or media_id)
    OPTIONAL unique id of the given input media.  If not provide a unique id
    should be assigned by the service: UNKNOWN_################.
    """
    subject_id: builtins.str
    """OPTIONAL unique id of the given input subject within a media.  If not provide a unique id
    should be assigned by the service: UNKNOWN_################.
    """
    type: global___EntryType.ValueType
    """subject_id or media_id"""
    name: builtins.str
    """name of subject, if known"""
    source: builtins.str
    """Describes the the media source"""
    @property
    def attributes(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Attribute]:
        """Used for passing additional metadata"""

    def __init__(
        self,
        *,
        database_id: builtins.str = ...,
        media_id: builtins.str = ...,
        subject_id: builtins.str = ...,
        type: global___EntryType.ValueType = ...,
        name: builtins.str = ...,
        source: builtins.str = ...,
        attributes: collections.abc.Iterable[global___Attribute] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["attributes", b"attributes", "database_id", b"database_id", "media_id", b"media_id", "name", b"name", "source", b"source", "subject_id", b"subject_id", "type", b"type"]) -> None: ...

global___EnrollmentInfo = EnrollmentInfo

@typing.final
class Record(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class MediaPreviewsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        @property
        def value(self) -> global___BriarMedia: ...
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: global___BriarMedia | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["value", b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None: ...

    @typing.final
    class SubjectPreviewsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        @property
        def value(self) -> global___BriarMedia: ...
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: global___BriarMedia | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["value", b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None: ...

    DATABASE_ID_FIELD_NUMBER: builtins.int
    ENTRY_ID_FIELD_NUMBER: builtins.int
    ENTRY_TYPE_FIELD_NUMBER: builtins.int
    SUBJECT_ID_FIELD_NUMBER: builtins.int
    NAME_FIELD_NUMBER: builtins.int
    MEDIA_ID_FIELD_NUMBER: builtins.int
    SOURCE_FIELD_NUMBER: builtins.int
    MODALITY_FIELD_NUMBER: builtins.int
    SOURCE_ID_FIELD_NUMBER: builtins.int
    ALGORITHM_FIELD_NUMBER: builtins.int
    NOTES_FIELD_NUMBER: builtins.int
    MEDIA_PREVIEWS_FIELD_NUMBER: builtins.int
    SUBJECT_PREVIEWS_FIELD_NUMBER: builtins.int
    DETECTION_FIELD_NUMBER: builtins.int
    TEMPLATES_FIELD_NUMBER: builtins.int
    TRACKLETS_FIELD_NUMBER: builtins.int
    ATTRIBUTES_FIELD_NUMBER: builtins.int
    entry_id: builtins.str
    """REQUIRED: database entry associated with this record"""
    entry_type: global___EntryType.ValueType
    """REQUIRED: Type of entry, either 'subject' or 'media'"""
    subject_id: builtins.str
    """OPTIONAL: ID of subject this record belong.  Leave blank if unknown."""
    name: builtins.str
    """OPTIONAL: Name of the subject. Subject may be unknown."""
    media_id: builtins.str
    source: builtins.str
    modality: global___BiometricModality.ValueType
    algorithm: builtins.str
    """OPTIONAL: Algorithm used to create the subject's templates"""
    notes: builtins.str
    """OPTIONAL: Additional notes about the subject or the media"""
    templates: builtins.str
    """OPTIONAL: A list of template ids associated with this entry."""
    tracklets: builtins.str
    """OPTIONAL: A list of tracklet_ids associated with this entry."""
    @property
    def database_id(self) -> global___BriarDatabase:
        """DEPRICATED, FOR LEGACY SYSTEMS ONLY Records are used to connect related information about media or a subject that is stored in a database.  Its structure may change in future API releases.
        This object is intened to hold information that is generally useful to humans.  The intension is that it will allow a GUI or similar tool to display basic inforamtion about the data base entry. For example, it would link an enrollment for a subject back to a passport like photo, name and other information.
        Ideally it should also support linking back to the source media, detection and tracking info, and other data that could be used to better understand how the media was processed.  Example: display source video with overlayed bounding boxes.
        REQUIRED: database associated with this record
        """

    @property
    def source_id(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """RECOMENDED: A list of source ids associated with this entry."""

    @property
    def media_previews(self) -> google.protobuf.internal.containers.MessageMap[builtins.str, global___BriarMedia]:
        """OPTIONAL: A small set of images representing the raw media. Example: a few low resolution frames."""

    @property
    def subject_previews(self) -> google.protobuf.internal.containers.MessageMap[builtins.str, global___BriarMedia]:
        """OPTIONAL: small previews that could be displayed for GUIs or manual verification of a subject.  Example: similar to mugshots or passport photos."""

    @property
    def detection(self) -> global___Detection: ...
    @property
    def attributes(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Attribute]:
        """OPTIONAL: Additional data about the record"""

    def __init__(
        self,
        *,
        database_id: global___BriarDatabase | None = ...,
        entry_id: builtins.str = ...,
        entry_type: global___EntryType.ValueType = ...,
        subject_id: builtins.str = ...,
        name: builtins.str = ...,
        media_id: builtins.str = ...,
        source: builtins.str = ...,
        modality: global___BiometricModality.ValueType = ...,
        source_id: collections.abc.Iterable[builtins.str] | None = ...,
        algorithm: builtins.str = ...,
        notes: builtins.str = ...,
        media_previews: collections.abc.Mapping[builtins.str, global___BriarMedia] | None = ...,
        subject_previews: collections.abc.Mapping[builtins.str, global___BriarMedia] | None = ...,
        detection: global___Detection | None = ...,
        templates: builtins.str = ...,
        tracklets: builtins.str = ...,
        attributes: collections.abc.Iterable[global___Attribute] | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["database_id", b"database_id", "detection", b"detection"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["algorithm", b"algorithm", "attributes", b"attributes", "database_id", b"database_id", "detection", b"detection", "entry_id", b"entry_id", "entry_type", b"entry_type", "media_id", b"media_id", "media_previews", b"media_previews", "modality", b"modality", "name", b"name", "notes", b"notes", "source", b"source", "source_id", b"source_id", "subject_id", b"subject_id", "subject_previews", b"subject_previews", "templates", b"templates", "tracklets", b"tracklets"]) -> None: ...

global___Record = Record

@typing.final
class RecordList(google.protobuf.message.Message):
    """DEPRICATED: records are not used at this time."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    RECORDS_FIELD_NUMBER: builtins.int
    @property
    def records(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Record]:
        """List of records"""

    def __init__(
        self,
        *,
        records: collections.abc.Iterable[global___Record] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["records", b"records"]) -> None: ...

global___RecordList = RecordList

@typing.final
class SearchMatchInfo(google.protobuf.message.Message):
    """messages

    Information about a match
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SCORE_FIELD_NUMBER: builtins.int
    THEORETICAL_MIN_FIELD_NUMBER: builtins.int
    THEORETICAL_MAX_FIELD_NUMBER: builtins.int
    SUBJECT_ID_PROBE_FIELD_NUMBER: builtins.int
    SUBJECT_ID_GALLERY_FIELD_NUMBER: builtins.int
    ENTRY_ID_PROBE_FIELD_NUMBER: builtins.int
    ENTRY_ID_GALLERY_FIELD_NUMBER: builtins.int
    MEDIA_ID_FIELD_NUMBER: builtins.int
    SUBJECT_NAME_FIELD_NUMBER: builtins.int
    FACE_FIELD_NUMBER: builtins.int
    BODY_FIELD_NUMBER: builtins.int
    GATE_FIELD_NUMBER: builtins.int
    USES_INTEGER_SUBJECT_ID_GALLERY_FIELD_NUMBER: builtins.int
    INTEGER_SUBJECT_ID_GALLERY_FIELD_NUMBER: builtins.int
    score: builtins.float
    """Match Similarity"""
    theoretical_min: builtins.float
    """OPTIONAL: the minimum score that the algorithm can return"""
    theoretical_max: builtins.float
    """OPTIONAL: the maximum score the algorithm can return"""
    subject_id_probe: builtins.str
    """DEPRECATED AND OPTIONAL: subject ID of probe image (if known, since usually probes do not have known subjects)"""
    subject_id_gallery: builtins.str
    """REQUIRED: subject ID of matched gallery subject"""
    entry_id_probe: builtins.str
    """OPTIONAL: the database entry id of the probe"""
    entry_id_gallery: builtins.str
    """OPTIONAL: the database entry id of the gallery"""
    media_id: builtins.str
    """OPTIONAL: ID of media that probe matched to"""
    subject_name: builtins.str
    """Name of subject"""
    uses_integer_subject_id_gallery: builtins.bool
    """DEPRECATED: FOR LEGACY SYSTEMS ONLY indicates that the gallery ID returned is of integer form"""
    integer_subject_id_gallery: builtins.int
    """DEPRECATED: FOR LEGACY SYSTEMS ONLY indicates that the gallery ID returned is of integer form"""
    @property
    def face(self) -> global___BriarMedia:
        """OPTIONAL: Image of face"""

    @property
    def body(self) -> global___BriarMedia:
        """OPTIONAL: Image of Body"""

    @property
    def gate(self) -> global___BriarMedia:
        """OPTIONAL: Image(s) of gait"""

    def __init__(
        self,
        *,
        score: builtins.float = ...,
        theoretical_min: builtins.float = ...,
        theoretical_max: builtins.float = ...,
        subject_id_probe: builtins.str = ...,
        subject_id_gallery: builtins.str = ...,
        entry_id_probe: builtins.str = ...,
        entry_id_gallery: builtins.str = ...,
        media_id: builtins.str = ...,
        subject_name: builtins.str = ...,
        face: global___BriarMedia | None = ...,
        body: global___BriarMedia | None = ...,
        gate: global___BriarMedia | None = ...,
        uses_integer_subject_id_gallery: builtins.bool = ...,
        integer_subject_id_gallery: builtins.int = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["body", b"body", "face", b"face", "gate", b"gate"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["body", b"body", "entry_id_gallery", b"entry_id_gallery", "entry_id_probe", b"entry_id_probe", "face", b"face", "gate", b"gate", "integer_subject_id_gallery", b"integer_subject_id_gallery", "media_id", b"media_id", "score", b"score", "subject_id_gallery", b"subject_id_gallery", "subject_id_probe", b"subject_id_probe", "subject_name", b"subject_name", "theoretical_max", b"theoretical_max", "theoretical_min", b"theoretical_min", "uses_integer_subject_id_gallery", b"uses_integer_subject_id_gallery"]) -> None: ...

global___SearchMatchInfo = SearchMatchInfo

@typing.final
class VerifyMatchInfo(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    SCORE_FIELD_NUMBER: builtins.int
    THEORETICAL_MIN_FIELD_NUMBER: builtins.int
    THEORETICAL_MAX_FIELD_NUMBER: builtins.int
    SUBJECT_ID_VERIFY_FIELD_NUMBER: builtins.int
    SUBJECT_ID_REFERENCE_FIELD_NUMBER: builtins.int
    ENTRY_ID_REFERENCE_FIELD_NUMBER: builtins.int
    ENTRY_ID_VERIFICATION_FIELD_NUMBER: builtins.int
    MEDIA_ID_FIELD_NUMBER: builtins.int
    SUBJECT_NAME_FIELD_NUMBER: builtins.int
    FACE_FIELD_NUMBER: builtins.int
    BODY_FIELD_NUMBER: builtins.int
    GATE_FIELD_NUMBER: builtins.int
    USES_INTEGER_GALLERY_ID_FIELD_NUMBER: builtins.int
    INTEGER_SUBJECT_ID_GALLERY_FIELD_NUMBER: builtins.int
    score: builtins.float
    """Match Similarity"""
    theoretical_min: builtins.float
    """OPTIONAL: the minimum score that the algorithm can return"""
    theoretical_max: builtins.float
    """OPTIONAL: the maximum score the algorithm can return"""
    subject_id_verify: builtins.str
    """OPTIONAL FOR EVALUATION: subject ID of image to be verified (if known)"""
    subject_id_reference: builtins.str
    """OPTIONAL: subject ID of reference image matched against"""
    entry_id_reference: builtins.str
    """OPTIONAL FOR EVALUATION: the database entry id of the reference image"""
    entry_id_verification: builtins.str
    """OPTIONAL FOR EVALUATION: the database entry id of the gallery"""
    media_id: builtins.str
    """OPTIONAL: ID of media that probe matched to"""
    subject_name: builtins.str
    """OPTIONAL: Name of subject"""
    uses_integer_gallery_id: builtins.bool
    """DEPRECATED: FOR LEGACY SYSTEMS ONLY indicates that the gallery ID returned is of integer form"""
    integer_subject_id_gallery: builtins.int
    """DEPRECATED: FOR LEGACY SYSTEMS ONLY indicates that the gallery ID returned is of integer form"""
    @property
    def face(self) -> global___BriarMedia:
        """OPTIONAL: Image of face"""

    @property
    def body(self) -> global___BriarMedia:
        """OPTIONAL: Image of Body"""

    @property
    def gate(self) -> global___BriarMedia:
        """OPTIONAL: Image(s) of gait"""

    def __init__(
        self,
        *,
        score: builtins.float = ...,
        theoretical_min: builtins.float = ...,
        theoretical_max: builtins.float = ...,
        subject_id_verify: builtins.str = ...,
        subject_id_reference: builtins.str = ...,
        entry_id_reference: builtins.str = ...,
        entry_id_verification: builtins.str = ...,
        media_id: builtins.str = ...,
        subject_name: builtins.str = ...,
        face: global___BriarMedia | None = ...,
        body: global___BriarMedia | None = ...,
        gate: global___BriarMedia | None = ...,
        uses_integer_gallery_id: builtins.bool = ...,
        integer_subject_id_gallery: builtins.int = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["body", b"body", "face", b"face", "gate", b"gate"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["body", b"body", "entry_id_reference", b"entry_id_reference", "entry_id_verification", b"entry_id_verification", "face", b"face", "gate", b"gate", "integer_subject_id_gallery", b"integer_subject_id_gallery", "media_id", b"media_id", "score", b"score", "subject_id_reference", b"subject_id_reference", "subject_id_verify", b"subject_id_verify", "subject_name", b"subject_name", "theoretical_max", b"theoretical_max", "theoretical_min", b"theoretical_min", "uses_integer_gallery_id", b"uses_integer_gallery_id"]) -> None: ...

global___VerifyMatchInfo = VerifyMatchInfo

@typing.final
class SearchMatchList(google.protobuf.message.Message):
    """List of matches"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MATCH_LIST_FIELD_NUMBER: builtins.int
    @property
    def match_list(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___SearchMatchInfo]:
        """REQUIRED: List of search matches in SORTED ORDER"""

    def __init__(
        self,
        *,
        match_list: collections.abc.Iterable[global___SearchMatchInfo] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["match_list", b"match_list"]) -> None: ...

global___SearchMatchList = SearchMatchList

@typing.final
class VerifyMatchList(google.protobuf.message.Message):
    """List of matches"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    MATCH_LIST_FIELD_NUMBER: builtins.int
    @property
    def match_list(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___VerifyMatchInfo]:
        """List of verification matches"""

    def __init__(
        self,
        *,
        match_list: collections.abc.Iterable[global___VerifyMatchInfo] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["match_list", b"match_list"]) -> None: ...

global___VerifyMatchList = VerifyMatchList

@typing.final
class BriarDatabase(google.protobuf.message.Message):
    """messages

    Stores images/detections/feature_vectors together in a searchable/referenceable data structure
    TODO: Gallery is implemented on the server but we have to completely populate the API it can be simple though: "name". No templates need to be tracked here.
    Leave this empty for performers to populate
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAME_FIELD_NUMBER: builtins.int
    name: builtins.str
    """An identifier for the gallery"""
    def __init__(
        self,
        *,
        name: builtins.str = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["name", b"name"]) -> None: ...

global___BriarDatabase = BriarDatabase

@typing.final
class BriarDatabaseInfo(google.protobuf.message.Message):
    """A message used for reporting information about a specific database"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    NAME_FIELD_NUMBER: builtins.int
    ENTRY_COUNT_FIELD_NUMBER: builtins.int
    TEMPLATE_COUNT_FIELD_NUMBER: builtins.int
    FAILED_ENROLLMENT_COUNT_FIELD_NUMBER: builtins.int
    TOTAL_DATABASE_SIZE_FIELD_NUMBER: builtins.int
    AVERAGE_ENTRY_SIZE_FIELD_NUMBER: builtins.int
    MODALITIES_FIELD_NUMBER: builtins.int
    ATTRIBUTES_FIELD_NUMBER: builtins.int
    ENTRY_IDS_FIELD_NUMBER: builtins.int
    TEMPLATES_PER_ENTRY_FIELD_NUMBER: builtins.int
    ENTRY_SIZES_FIELD_NUMBER: builtins.int
    name: builtins.str
    """REQUIRED: database name"""
    entry_count: builtins.int
    """REQUIRED: number of entries in the database"""
    template_count: builtins.int
    """REQUIRED: number of unique templates in the database (could be larger than number of entries)"""
    failed_enrollment_count: builtins.int
    """REQUIRED: number of failed enrollments into the database"""
    total_database_size: builtins.float
    """REQUIRED FOR EVALUATION: size of database in KB"""
    average_entry_size: builtins.float
    """REQUIRED FOR EVALUATION: average size of an entry in KB"""
    @property
    def modalities(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[global___BiometricModality.ValueType]:
        """OPTIONAL: modality of the database (could be multiple if the database includes multiple modalities)"""

    @property
    def attributes(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___Attribute]:
        """OPTIONAL: other attributes that may be custom to a performers"""

    @property
    def entry_ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """REQUIRED FOR EVALUATION: Returns a list of all entries (as denoted by their appropriate "entryId" from signature set) contained within the database"""

    @property
    def templates_per_entry(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.int]:
        """OPTIONAL : Returns the number of templates used to generate a each entry. Should be in the same order as "entry_ids" """

    @property
    def entry_sizes(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.float]:
        """REQUIRED FOR EVALUATION: return the stored size of each entry in the database (KB) in the same order as entry_ids"""

    def __init__(
        self,
        *,
        name: builtins.str = ...,
        entry_count: builtins.int = ...,
        template_count: builtins.int = ...,
        failed_enrollment_count: builtins.int = ...,
        total_database_size: builtins.float = ...,
        average_entry_size: builtins.float = ...,
        modalities: collections.abc.Iterable[global___BiometricModality.ValueType] | None = ...,
        attributes: collections.abc.Iterable[global___Attribute] | None = ...,
        entry_ids: collections.abc.Iterable[builtins.str] | None = ...,
        templates_per_entry: collections.abc.Iterable[builtins.int] | None = ...,
        entry_sizes: collections.abc.Iterable[builtins.float] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["attributes", b"attributes", "average_entry_size", b"average_entry_size", "entry_count", b"entry_count", "entry_ids", b"entry_ids", "entry_sizes", b"entry_sizes", "failed_enrollment_count", b"failed_enrollment_count", "modalities", b"modalities", "name", b"name", "template_count", b"template_count", "templates_per_entry", b"templates_per_entry", "total_database_size", b"total_database_size"]) -> None: ...

global___BriarDatabaseInfo = BriarDatabaseInfo

@typing.final
class TemplateIds(google.protobuf.message.Message):
    """A message representing a list of unique template ids."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    IDS_FIELD_NUMBER: builtins.int
    LENGTH_FIELD_NUMBER: builtins.int
    length: builtins.int
    """DEPRICATED: not needed in protobuf. Number of ids"""
    @property
    def ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """List of unique ids relating to the templates"""

    def __init__(
        self,
        *,
        ids: collections.abc.Iterable[builtins.str] | None = ...,
        length: builtins.int = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["ids", b"ids", "length", b"length"]) -> None: ...

global___TemplateIds = TemplateIds

@typing.final
class ClusterIds(google.protobuf.message.Message):
    """messages

    A message to represent a list of cluster ids objects.
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    IDS_FIELD_NUMBER: builtins.int
    @property
    def ids(self) -> google.protobuf.internal.containers.RepeatedScalarFieldContainer[builtins.str]:
        """List of ids to cluster"""

    def __init__(
        self,
        *,
        ids: collections.abc.Iterable[builtins.str] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["ids", b"ids"]) -> None: ...

global___ClusterIds = ClusterIds

@typing.final
class ClusterConfidence(google.protobuf.message.Message):
    """A messageure to represent a list of cluster confidence objects."""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    CONFIDENCES_FIELD_NUMBER: builtins.int
    confidences: builtins.float
    """Confidence of the cluster"""
    def __init__(
        self,
        *,
        confidences: builtins.float = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["confidences", b"confidences"]) -> None: ...

global___ClusterConfidence = ClusterConfidence

@typing.final
class BriarDuration(google.protobuf.message.Message):
    """----------------------------------------------------------------------------
    Analytics messages
    """

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    START_FIELD_NUMBER: builtins.int
    END_FIELD_NUMBER: builtins.int
    start: builtins.float
    """start time of process in Seconds Since the Epoch (SSTE)"""
    end: builtins.float
    """start time of process in Seconds Since the Epoch (SSTE)"""
    def __init__(
        self,
        *,
        start: builtins.float = ...,
        end: builtins.float = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["end", b"end", "start", b"start"]) -> None: ...

global___BriarDuration = BriarDuration

@typing.final
class BriarDurations(google.protobuf.message.Message):
    """Data structure to contain timing information for BRIAR functions. All timing information is in microseconds"""

    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    @typing.final
    class SubDurationsEntry(google.protobuf.message.Message):
        DESCRIPTOR: google.protobuf.descriptor.Descriptor

        KEY_FIELD_NUMBER: builtins.int
        VALUE_FIELD_NUMBER: builtins.int
        key: builtins.str
        @property
        def value(self) -> global___BriarDuration: ...
        def __init__(
            self,
            *,
            key: builtins.str = ...,
            value: global___BriarDuration | None = ...,
        ) -> None: ...
        def HasField(self, field_name: typing.Literal["value", b"value"]) -> builtins.bool: ...
        def ClearField(self, field_name: typing.Literal["key", b"key", "value", b"value"]) -> None: ...

    CLIENT_DURATION_FILE_LEVEL_FIELD_NUMBER: builtins.int
    CLIENT_DURATION_FRAME_LEVEL_FIELD_NUMBER: builtins.int
    GRPC_OUTBOUND_TRANSFER_DURATION_FIELD_NUMBER: builtins.int
    GRPC_INBOUND_TRANSFER_DURATION_FIELD_NUMBER: builtins.int
    SERVICE_DURATION_FIELD_NUMBER: builtins.int
    SUB_DURATIONS_FIELD_NUMBER: builtins.int
    TOTAL_DURATION_FIELD_NUMBER: builtins.int
    @property
    def client_duration_file_level(self) -> global___BriarDuration:
        """This will always be populated with the duration taken by the BRIAR API client for the file-level operations"""

    @property
    def client_duration_frame_level(self) -> global___BriarDuration:
        """This will always be populated with the duration taken by the BRIAR API client for the frame-level operations"""

    @property
    def grpc_outbound_transfer_duration(self) -> global___BriarDuration:
        """This will always be populated by the duration taken to perform the outbound API request across the gRPC channel"""

    @property
    def grpc_inbound_transfer_duration(self) -> global___BriarDuration:
        """This will always be populated by the duration taken to perform the inbound API data response across the gRPC channel"""

    @property
    def service_duration(self) -> global___BriarDuration: ...
    @property
    def sub_durations(self) -> google.protobuf.internal.containers.MessageMap[builtins.str, global___BriarDuration]:
        """A list of timings of subroutines within a function"""

    @property
    def total_duration(self) -> global___BriarDuration:
        """The total time in microseconds it took to execute the function"""

    def __init__(
        self,
        *,
        client_duration_file_level: global___BriarDuration | None = ...,
        client_duration_frame_level: global___BriarDuration | None = ...,
        grpc_outbound_transfer_duration: global___BriarDuration | None = ...,
        grpc_inbound_transfer_duration: global___BriarDuration | None = ...,
        service_duration: global___BriarDuration | None = ...,
        sub_durations: collections.abc.Mapping[builtins.str, global___BriarDuration] | None = ...,
        total_duration: global___BriarDuration | None = ...,
    ) -> None: ...
    def HasField(self, field_name: typing.Literal["client_duration_file_level", b"client_duration_file_level", "client_duration_frame_level", b"client_duration_frame_level", "grpc_inbound_transfer_duration", b"grpc_inbound_transfer_duration", "grpc_outbound_transfer_duration", b"grpc_outbound_transfer_duration", "service_duration", b"service_duration", "total_duration", b"total_duration"]) -> builtins.bool: ...
    def ClearField(self, field_name: typing.Literal["client_duration_file_level", b"client_duration_file_level", "client_duration_frame_level", b"client_duration_frame_level", "grpc_inbound_transfer_duration", b"grpc_inbound_transfer_duration", "grpc_outbound_transfer_duration", b"grpc_outbound_transfer_duration", "service_duration", b"service_duration", "sub_durations", b"sub_durations", "total_duration", b"total_duration"]) -> None: ...

global___BriarDurations = BriarDurations

@typing.final
class BriarDurationsList(google.protobuf.message.Message):
    DESCRIPTOR: google.protobuf.descriptor.Descriptor

    DURATIONS_LIST_FIELD_NUMBER: builtins.int
    @property
    def durations_list(self) -> google.protobuf.internal.containers.RepeatedCompositeFieldContainer[global___BriarDurations]: ...
    def __init__(
        self,
        *,
        durations_list: collections.abc.Iterable[global___BriarDurations] | None = ...,
    ) -> None: ...
    def ClearField(self, field_name: typing.Literal["durations_list", b"durations_list"]) -> None: ...

global___BriarDurationsList = BriarDurationsList
